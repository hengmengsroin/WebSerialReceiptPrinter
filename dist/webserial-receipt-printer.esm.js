class t{constructor(t){this._events={}}on(t,e){this._events[t]=this._events[t]||[],this._events[t].push(e)}emit(t,...e){let s=this._events[t];s&&s.forEach((t=>{setTimeout((()=>t(...e)),0)}))}}class e{}class s extends e{#t;#e={};#s=null;#n=null;#r=[];#i={running:!1,closing:!1};constructor(e){super(),this.#t=new t,this.#e=Object.assign({baudRate:9600,bufferSize:255,dataBits:8,flowControl:"none",parity:"none",stopBits:1},e),navigator.serial.addEventListener("disconnect",(t=>{this.#s==t.target&&this.#t.emit("disconnected")}))}async connect(){try{let t=await navigator.serial.requestPort();return!!t&&(await this.#a(t),!0)}catch(t){return console.log("Could not connect! "+t),!1}}async reconnect(t){if(!t.vendorId||!t.productId)return;let e=(await navigator.serial.getPorts()).filter((e=>{let s=e.getInfo();return s.usbVendorId==t.vendorId&&s.usbProductId==t.productId}));1==e.length&&await this.#a(e[0])}async#a(t){try{this.#s=t,this.#i.closing=!1,await this.#s.open(this.#e);let e=this.#s.getInfo();return this.#t.emit("connected",{type:"serial",vendorId:e.usbVendorId||null,productId:e.usbProductId||null,language:null,codepageMapping:null}),!0}catch(t){return console.log("Could not open port! "+t),!1}}async disconnect(){this.#s&&(this.#i.closing=!0,this.#n.cancel(),await this.#n.closed,await this.#s.close(),this.#s=null,this.#t.emit("disconnected"))}async listen(){return this.#o(),!0}async#o(){for(;this.#s.readable&&!1===this.#i.closing;){this.#n=this.#s.readable.getReader();try{for(;;){const{value:t,done:e}=await this.#n.read();if(e)break;t&&this.#t.emit("data",t)}}catch(t){}finally{this.#n.releaseLock()}}}async print(t){this.#r.push(t),this.run()}async run(){if(this.#i.closing)return;if(this.#i.running)return;this.#i.running=!0;const t=this.#s.writable.getWriter();let e;for(;e=this.#r.shift();)await t.write(e);t.releaseLock(),this.#i.running=!1}addEventListener(t,e){this.#t.on(t,e)}}export{s as default};
//# sourceMappingURL=webserial-receipt-printer.esm.js.map
